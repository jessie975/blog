--- 
title: 正则学习
date: 2019-10-30 17:50:20
sidebar: 'auto'
categories: 
 - 学习总结
tags: 
 - 正则
publish: true
---
习惯了面向搜索引擎编程的我对于正则一直都是得过且过，但是为了成为一名合格的攻城狮，如今我决定痛改前非，不让自己生活在舒适区，趁年轻，学就完事儿了~

## 几个经典表单验证初始正则

**匹配手机号**：

```js
let reg = /^1(3[0-9]|5[012356789]|66|7[3678]|8[0-9]|4[57])[0-9]{8}$/
let phone = '13386472394'
console.log(reg.test(phone)) // true
```  

`^`: 开头  
`$`: 结尾  
`|`: 或  
`-`: 定义一个区间
`()`: 一个元组  
`[]`: 定义一个字符集合，匹配字符集合中的一个字符，在字符集合里面像 .，\这些字符都表示其本身  
`{m,n}`: 匹配前面一个字符至少 m 次至多 n 次重复，还有{m}表示匹配 m 次，{m,}表示至少 m 次  

分析：以1开头，小括号里的匹配了手机号的第二位和第三位，如果第二位数字是3，则第三位数是0~9中的一个，如果第二位是5，则第三位数字是012356789中的一个，依次类推，从第四位数字开始就可以是任意的数字了，循环取任意的数字8次结尾，这样11位的手机号就匹配出来了。

**匹配邮箱**：

```js
let reg2 = /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/
let email = 'y_1+d@qq.12.com'
console.log(reg2.test(email)) // true
```

`\w`: 表示数字大小写字母和下划线  
`\W`: 表示非单词字符  
`+`: 匹配前面一个表达式**一次**或者多次，至少要有一次  
`*`: 匹配前面一个表达式**零次**或者多次，可以没有  
`\`: 转义字符，后面跟特殊字符表示匹配特殊字符，例如`/a\*/`将匹配`a*`，而不是匹配零个或多个a  

分析：可以用至少一个数字或字母或下划线开头，字符中间可以穿插-、+、.这三个字符，也可以没有，以@符号分隔，看懂了前面后面就好理解了。  

**URL匹配**：

```js
let reg3 = /^((ht|f)tps?):\/\/[\w\-]+(\.[\w\-]+)+([\w\-.,@?^=%&:\/~+#]*[\w\-@?^=%&\/~+#])?$/
let url = 'https://baidu.com'
console.log(reg3.test(url)) // true
```

`?`: 单独使用匹配前面一个表达式**零次**或者**一次**, 如果跟在任何量词*,+,?,{}后面的时候将会使量词变为非贪婪模式（尽量匹配少的字符），默认是使用贪婪模式。比如对 "123abc" 应用 /\d+/ 将会返回 "123"，如果使用 /\d+?/,那么就只会匹配到 "1"  
`.`: 匹配除换行符之外的任意字符

分析：  
`^((ht|f)tps?)`: 匹配http|ftp|https|ftps，`s?`表示s出现零次或一次  
`\/\/`: 匹配两个斜杠  
`[\w\-]+`: 匹配一个或多个数字、字母、下划线、-  
`(\.[\w\-]+)+`: 匹配一组或多组以.开头，一个或多个数字、字母、下划线、-结尾的字符串  
`[\w\-.,@?^=%&:\/~+#]*`: 匹配零个或多个特殊字符组成字符串A，这些字符包含数字、字母、下划线、-、除换行外任意字符、,、@、？、^、=、%、&、:、\、~、+、#  
`[\w\-@?^=%&\/~+#]`: 匹配一个中括号中的特殊字符B  
`([\w\-.,@?^=%&:\/~+#]*[\w\-@?^=%&\/~+#])?`: 匹配零组或一组由字符串A和字符B组成的字符串  

## 常用字符匹配学习字符串使用正则的方法

**匹配中文字符**:  

```js
let reg4 = /[\u4e00-\u9fa5]/gm
let chinese = '正则^表达式123**&&'
console.log(chinese.match(reg4)) // [ '正', '则', '表', '达', '式' ]
```

`\u`: 按unicode(utf-8)匹配（主要针对多字节比如汉字）  
`4e00-9fa5`: 中日韩认同表意文字区，总计收容20,902个中日韩汉字  
`g`: 进行全局匹配，即对字符串进行全文匹配，直到字符串遍历结束  
`m`: 更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.)  

**匹配行尾和行尾行首空格**:  

```js
let reg5 = /(^\s*)|(\s*$)/g
let part = ` 十年生死两茫茫  写程序  到天亮  千行代码  bug何处藏`
console.log(part.replace(reg5,'**')) // **十年生死两茫茫  写程序  到天亮  千行代码  bug何处藏**
```

`\s`: 匹配任意空白符  

**给日期换一个格式**:  

```js
let reg6 = /^(\d{4})[/-](\d{2})[/-](\d{2})$/
let time = '2019-10-30'
console.log(time.replace(reg6, '$1年$2月$3日')) // 2019年10月30日
console.log(time.replace(reg6, '$1/$2/$3/')) // 2019/10/30/
```

`$1`: 匹配第一组,即第一个括号中的内容  

## 未完待续

还有一些进阶的方法等待学习，先入个门，后面慢慢找时间学习~
[各字符总结](https://www.baidufe.com/item/eb10deb92f2c05ca32cf.html)
