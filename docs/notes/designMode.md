--- 
title: 《JavaScript设计模式》读书笔记
date: 2020-08-21 09:33:13
sidebar: 'auto'
categories: 
 - 读书笔记
tags: 
 - 读书笔记
publish: true
---

之前对于设计模式的学习一直处于功利的心态，觉得这种东西只要别人问起来的时候自己略知一二就可以了，所以之前虽然对于设计模式也做过不少『记录』，但都只是知道，并没有深入理解，所以最近买了一本《JavaScript设计模式与开发实践》来学习，所谓好记性不如烂笔头嘛，这里就写一篇博客来做一些学习笔记

## 关于设计模式

### 定义

- 书中的定义: 在面向对象软件设计过程中针对**特定问题**的简洁而优雅的**解决方案**
- 我的理解: 就是给特定情况下的一些优秀的代码实践起一个名字
- 遵循的原则: 找出程序中变化的地方，并将变化封装起来

### 作用

在软件设计中，模式是经过大量实践项目验证的优秀解决方案，掌握这些设计模式，当遇到合适的场景，会自然而然的想到优雅的解决方案。比如：当看到系统中存在一些大量的相似对象，这些对象给系统的内存带来了较大的负担，那么这个时候就会想到用**享元模式**来优化这个系统；再比如，系统中的某个接口的结构已经不能符合目前的需求，但又不想去改动老接口，这时候就能很快想到可以用**适配器模式**来解决这个问题......  
虽然从某些角度来看，设计模式有可能会带来额外的代码量，有时候甚至会增加系统的复杂度，但软件开发的成本并非全部在开发阶段，设计模式能够帮助我们写出**可复用**和**可维护性高**的程序，因此，设计模式有必要好好的去学习。

## 基础知识

### 面向对象的JavaScript

编程语言按照数据类型大体可以分为**静态类型语言**和**动态类型语言**两大类

#### 静态类型语言

- 在**编译时**就已经确定了变量的类型
- 优点：编辑器在编译时就能发现程序中类型不匹配的错误，由于明确规定了数据类型，所以编辑器会针对这些信息对程序进行优化，提升程序执行速度
- 缺点：需要给每个变量规定数据类型，增加额外的代码量，导致精力无法完全集中到业务逻辑中来

#### 动态类型语言

- **程序运行时**才能确定变量的类型
- 优点：代码看起来更简洁，程序员可以把精力放在业务逻辑中
- 缺点：无法保证变量的类型，程序运行时可能发生错误

由此可见JavaScript是一种典型的动态类型语言（但是TypeScript近两年越来越流行，感觉js要向静态类型语言看齐了）。关于面向对象这个词，我觉得书中说的一个**鸭子模型**让我很好的理解了这个词，这个故事也想分享给大家：

> 从前在JavaScript王国里，有一个国王，他觉得世界上最美妙的声音就是鸭子的叫声，于是国王召集大臣，要组建一个1000只鸭子组成的合唱团。大臣们找遍了全国，终于找到999只鸭子，但是始终只差一只，最后大臣发现有一只非常特别的鸡，它的叫声跟鸭子一模一样，于是这只鸡就成为合唱团的最后一员。

国王想要的只是鸭子的叫声，不管它是鸡是狗，只要它能够发出鸭子的叫声就行，这就像我们的js，不管它是什么数据类型，只要它拥有length、splice这些数组的方法，它就能被当成数组使用，最典型的一个例子就是取一个数组中的最大值就可以这样来写：

```js
const arr = [3, 5, 1, 6, 9, 2]
Math.max.apply(null, arr) // 9
```

## 闭包和高阶函数

### 闭包

闭包这个词虽然已经学习过很多次了，但是被问到的时候还是会说得不太完整。

闭包的形成与**变量的作用域**以及**变量的生存周期**密切相关

关于变量的作用域最开始我认为只要用var声明的变量都是『全局变量』，但是当在函数中用var声明变量，那这个时候的变量就是『局部变量』了，而变量的搜索过程是**由内而外**的，也就是说搜索变量是从变量声明的地方根据作用域的关系，依次向上寻找，也就是说内层作用域能够访问到外层作用域的变量，而外层作用域就访问不到内层作用域的变量。

接下来再看看变量的生存周期，我们知道js中有一个垃圾回收机制，程序会判断变量是否失去调用的价值从而销毁不必要的变量。全局变量的生存周期是永久的，除非手动销毁，而局部变量将在该函数作用域调用后被销毁

看一个闭包的例子：

```js
const func = () => {
  var a = 1
  return function() {
    a++
    console.log(a)
  }
}
const f = func()

f() // 2
f() // 3
```

根据我们刚才的推论，变量a应该在调用后就被销毁了，但是接下来还是能访问到a。这是因为当执行了const f = func()，f返回了一个匿名函数的引用，它可以访问到func()被调用时产生的环境，而局部变量a一直处在这个环境中。既然局部变量所在的环境还能被外界访问，这个局部变量就有了不被销毁的理由。这里就产生了一个闭包结构，局部变量的生存周期被延续了。因此，闭包也常用于**延续变量的生存周期**以及**封装变量**
