--- 
title: 《JavaScript设计模式》读书笔记
date: 2020/08/21
sidebar: 'auto'
categories: 
 - 读书笔记
tags: 
 - 读书笔记
publish: true
---

之前对于设计模式的学习一直处于功利的心态，觉得这种东西只要别人问起来的时候自己略知一二就可以了，所以之前虽然对于设计模式也做过不少『记录』，但都只是知道，并没有深入理解，所以最近买了一本《JavaScript设计模式与开发实践》来学习，看过之后对有些代码的理解有了茅塞顿开的感觉，故通过笔记记录下书中一些知识以及自己对这些知识的理解。

## 关于设计模式

### 定义

- 书中的定义: 在面向对象软件设计过程中针对**特定问题**的简洁而优雅的**解决方案**
- 我的理解: 就是给特定情况下的一些优秀的代码实践起一个名字
- 遵循的原则: 找出程序中变化的地方，并将变化封装起来

### 作用

在软件设计中，模式是经过大量实践项目验证的优秀解决方案，掌握这些设计模式，当遇到合适的场景，会自然而然的想到优雅的解决方案。比如：当看到系统中存在一些大量的相似对象，这些对象给系统的内存带来了较大的负担，那么这个时候就会想到用**享元模式**来优化这个系统；再比如，系统中的某个接口的结构已经不能符合目前的需求，但又不想去改动老接口，这时候就能很快想到可以用**适配器模式**来解决这个问题......  
虽然从某些角度来看，设计模式有可能会带来额外的代码量，有时候甚至会增加系统的复杂度，但软件开发的成本并非全部在开发阶段，设计模式能够帮助我们写出**可复用**和**可维护性高**的程序，因此，设计模式有必要好好的去学习。

## 基础知识

### 面向对象的JavaScript

编程语言按照数据类型大体可以分为**静态类型语言**和**动态类型语言**两大类

#### 静态类型语言

- 在**编译时**就已经确定了变量的类型
- 优点：编辑器在编译时就能发现程序中类型不匹配的错误，由于明确规定了数据类型，所以编辑器会针对这些信息对程序进行优化，提升程序执行速度
- 缺点：需要给每个变量规定数据类型，增加额外的代码量，导致精力无法完全集中到业务逻辑中来

#### 动态类型语言

- **程序运行时**才能确定变量的类型
- 优点：代码看起来更简洁，程序员可以把精力放在业务逻辑中
- 缺点：无法保证变量的类型，程序运行时可能发生错误

由此可见JavaScript是一种典型的动态类型语言（但是TypeScript近两年越来越流行，感觉js要向静态类型语言看齐了）。关于面向对象这个词，我觉得书中说的一个**鸭子模型**让我很好的理解了这个词，这个故事也想分享给大家：

> 从前在JavaScript王国里，有一个国王，他觉得世界上最美妙的声音就是鸭子的叫声，于是国王召集大臣，要组建一个1000只鸭子组成的合唱团。大臣们找遍了全国，终于找到999只鸭子，但是始终只差一只，最后大臣发现有一只非常特别的鸡，它的叫声跟鸭子一模一样，于是这只鸡就成为合唱团的最后一员。

国王想要的只是鸭子的叫声，不管它是鸡是狗，只要它能够发出鸭子的叫声就行，这就像我们的js，不管它是什么数据类型，只要它拥有length、splice这些数组的方法，它就能被当成数组使用，最典型的一个例子就是取一个数组中的最大值就可以这样来写：

```js
const arr = [3, 5, 1, 6, 9, 2]
Math.max.apply(null, arr) // 9
```

## 闭包和高阶函数

### 闭包

闭包这个词虽然已经学习过很多次了，但是被问到的时候还是会说得不太完整。

闭包的形成与**变量的作用域**以及**变量的生存周期**密切相关

关于变量的作用域最开始我认为只要用var声明的变量都是『全局变量』，但是当在函数中用var声明变量，那这个时候的变量就是『局部变量』了，而变量的搜索过程是**由内而外**的，也就是说搜索变量是从变量声明的地方根据作用域的关系，依次向上寻找，也就是说内层作用域能够访问到外层作用域的变量，而外层作用域就访问不到内层作用域的变量。

接下来再看看变量的生存周期，我们知道js中有一个垃圾回收机制，程序会判断变量是否失去调用的价值从而销毁不必要的变量。全局变量的生存周期是永久的，除非手动销毁，而局部变量将在该函数作用域调用后被销毁

看一个闭包的例子：

```js
const func = () => {
  var a = 1
  return function() {
    a++
    console.log(a)
  }
}
const f = func()

f() // 2
f() // 3
```

根据我们刚才的推论，变量a应该在调用后就被销毁了，但是接下来还是能访问到a。这是因为当执行了const f = func()，f返回了一个匿名函数的引用，它可以访问到func()被调用时产生的环境，而局部变量a一直处在这个环境中。既然局部变量所在的环境还能被外界访问，这个局部变量就有了不被销毁的理由。这里就产生了一个闭包结构，局部变量的生存周期被延续了。因此，闭包也常用于**延续变量的生存周期**以及**封装变量**

### 高阶函数

高阶函数是指至少满足下列条件之一的函数：

- 函数可以作为参数被传递
- 函数可以作为返回值输出

所以我们的回调函数和函数柯里化的应用都属于高阶函数，回调函数就不必介绍了，再次说说函数柯里化（function currying）吧。

#### 函数柯里化

currying又称部分求值。一个currying的函数首先会接受一些函数，接受了这些函数之后，该函数并不会立即求值，而是继续返回另一个函数，**刚才传入的参数在函数形成的闭包中被保护起来**，待到函数真正需要求值的时候，之前传入的所有参数都会被一次性用于求值

记下书中的一个例子便于今后理解

```js
const currying = function(fn) {
  const args = []
  return function() {
    if (arguments.length === 0) {
      return fn.apply(this, args)
    } else {
      [].push.apply(args, arguments)
      return arguments.callee   // callee 属性包含当前正在执行的函数，也就是匿名函数的一种递归调用方式，但是ES5已经禁止使用了
    }
  }
}

const const = (function() {
  let money = 0
  return function() {
    for (let i = 0, l = arguments.length; i < l; i++) {
      money += arguments[i]
    }
    return money
  }
})()

const cost = currying(const) // 换转成currying函数

cost(100) // 未真正求值
cost(200) // 未真正求值
cost(300) // 未真正求值

alert(cost()) // 求值并输出： 600

```

接下来就进入正题吧，这篇读书笔记只挑选了平时常用的几种模式进行总结记录

- 单例模式
- 策略模式
- 代理模式
- 发布-订阅模式
- 命令模式
- 中介者模式
- 装饰者模式
- 适配器模式

## 单例模式

> 定义：有且仅有一个对象的实例。JS的单例模式有别于传统面向对象语言的单例模式，js作为一门无类的语言。使用全局变量的模式来实现单例模式思想。
> 适用场景：单点登录

```js
var getSingle = function (fn) {
  var result;
  return function () {
    return result || (result = fn.apply(this, arguments));
  }
};
```

## 策略模式

> 定义： 定义一系列的算法，把它们一个个的封装起来，并且使他们可以相互替换

自从学习这个模式之后，我就再也看不惯代码里大量的『if else』了，举一个我遇到的策略模式最简单的例子：

我同事写的代码是这样的：

```js
if(cityStr == "gy"){
  app.globalData.dsdata="贵阳";
  app.globalData.cityStr = "gy";
}else if(cityStr=="zy"){
  app.globalData.dsdata="遵义";
  app.globalData.cityStr = "zy";
}else if(cityStr=="as"){
  app.globalData.dsdata="安顺";
  app.globalData.cityStr = "as";
}else if(cityStr=="bj"){
  app.globalData.dsdata="毕节";
  app.globalData.cityStr = "bj";
}else if(cityStr=="tr"){
  app.globalData.dsdata="铜仁";
  app.globalData.cityStr = "tr";
}else if(cityStr=="lps"){
  app.globalData.dsdata="六盘水";
  app.globalData.cityStr = "lps";
}else if(cityStr=="qn"){
  app.globalData.dsdata="黔南";
  app.globalData.cityStr = "qn";
}else if(cityStr=="qxn"){
  app.globalData.dsdata="黔西南";
  app.globalData.cityStr = "qxn";
}else if(cityStr=="qdn"){
  app.globalData.dsdata="黔东南";
  app.globalData.cityStr = "qdn";
}else{
  app.globalData.dsdata="省级";
  app.globalData.cityStr = "gz";
}
```

我学习了策略模式之后写的代码：（同样的功能）

```js
const cityMap = {
  gy: '贵阳',
  zy: '遵义',
  as: '安顺',
  bj: '毕节',
  tr: '铜仁',
  lps: '六盘水',
  qn: '黔南',
  qxn: '黔西南',
  qdn: '黔东南'
}
app.globalData.city = cityMap[city] || '省级'
```

是不是简洁很多呢，这就是学习设计模式的魅力，可以写出让别人说出『原来还可以这样写』的代码，这种感觉会上瘾。

## 代理模式

> 定义：为一个对象提供一个代用品或占位符，以便控制对他的访问。代理模式的关键是：当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制对这个对象的访问

## 发布-订阅模式

> 定义：又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。vue中状态管理也就使用了这种模式。

## 命令模式

> 定义：命令模式中的命令指的是一个执行某些特定事情的指令。
> 适用场景：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么，此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。

## 中介者模式

> 定义：中介者模式的作用就是解决对象与对象之间的紧耦合关系。

## 装饰者模式

> 定义：对对象动态的添加职责。这个模式有点像js的继承，但是装饰者模式更灵活更轻便，它是一种『即用即付』的方式，比如天冷了就加衣服......

## 适配器模式

> 定义：适配器模式的作用是解决两个软件实体间的接口不兼容的问题。
> 适用场景：当我们试图调用模块或者对象的某个接口时，却发现这个接口的格式并不符合目前的需求。这时候有两种解决办法：①修改原来的接口实现，但如果原来的模块很复杂，或者我们拿到的模块是一段别人编写的经过压缩的代码，修改原接口就显得不太现实了。②创建一个适配器，将原来的接口转换成客户希望的另一个接口，客户只需要和适配器打交道。

先暂时写到这里，最近工作比较忙，等闲下来再补充以上模式的代码实例......
