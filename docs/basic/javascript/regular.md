--- 
title: 学正则不用栗子怎么行
date: 2019/10/30
sidebar: 'auto'
categories: 
 - 前端那些事儿
tags: 
 - 正则
publish: true
---
习惯了面向搜索引擎编程的我对于正则一直都是得过且过，但是为了成为一名合格的攻城狮，如今我决定痛改前非，不让自己生活在舒适区，趁年轻，学就完事儿了~

## 匹配字符

### 匹配手机号

```js
let reg = /^1(3[0-9]|5[012356789]|66|7[3678]|8[0-9]|4[57])[0-9]{8}$/
let phone = '13386472394'
console.log(reg.test(phone)) // true
```  

`^`: 开头  
`$`: 结尾  
`|`: 或  
`-`: 定义一个区间
`()`: 一个元组  
`[]`: 定义一个字符集合，匹配字符集合中的一个字符，在字符集合里面像 .，\这些字符都表示其本身  
`{m,n}`: 匹配前面一个字符至少 m 次至多 n 次重复，还有{m}表示匹配 m 次，{m,}表示至少 m 次  

分析：以1开头，小括号里的匹配了手机号的第二位和第三位，如果第二位数字是3，则第三位数是0~9中的一个，如果第二位是5，则第三位数字是012356789中的一个，依次类推，从第四位数字开始就可以是任意的数字了，循环取任意的数字8次结尾，这样11位的手机号就匹配出来了。

### 匹配邮箱

```js
let reg = /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/
let email = 'y_1+d@qq.12.com'
console.log(reg.test(email)) // true
```

`\w`: 表示数字大小写字母和下划线  
`\W`: 表示非单词字符  
`+`: 匹配前面一个表达式**一次**或者多次，至少要有一次  
`*`: 匹配前面一个表达式**零次**或者多次，可以没有  
`\`: 转义字符，后面跟特殊字符表示匹配特殊字符，例如`/a\*/`将匹配`a*`，而不是匹配零个或多个a  

分析：可以用至少一个数字或字母或下划线开头，字符中间可以穿插-、+、.这三个字符，也可以没有，以@符号分隔，看懂了前面后面就好理解了。  

### URL匹配

```js
let reg = /^((ht|f)tps?):\/\/[\w\-]+(\.[\w\-]+)+([\w\-.,@?^=%&:\/~+#]*[\w\-@?^=%&\/~+#])?$/
let url = 'https://baidu.com'
console.log(reg.test(url)) // true
```

`?`: 单独使用匹配前面一个表达式**零次**或者**一次**, 如果跟在任何量词*,+,?,{}后面的时候将会使量词变为非贪婪模式（尽量匹配少的字符），默认是使用贪婪模式。比如对 "123abc" 应用 /\d+/ 将会返回 "123"，如果使用 /\d+?/,那么就只会匹配到 "1"  
`.`: 匹配除换行符之外的任意字符

分析：  
`^((ht|f)tps?)`: 匹配http|ftp|https|ftps，`s?`表示s出现零次或一次  
`\/\/`: 匹配两个斜杠  
`[\w\-]+`: 匹配一个或多个数字、字母、下划线、-  
`(\.[\w\-]+)+`: 匹配一组或多组以.开头，一个或多个数字、字母、下划线、-结尾的字符串  
`[\w\-.,@?^=%&:\/~+#]*`: 匹配零个或多个特殊字符组成字符串A，这些字符包含数字、字母、下划线、-、除换行外任意字符、,、@、？、^、=、%、&、:、\、~、+、#  
`[\w\-@?^=%&\/~+#]`: 匹配一个中括号中的特殊字符B  
`([\w\-.,@?^=%&:\/~+#]*[\w\-@?^=%&\/~+#])?`: 匹配零组或一组由字符串A和字符B组成的字符串  

### 匹配中文字符

```js
let reg = /[\u4e00-\u9fa5]/gm
let chinese = '正则^表达式123**&&'
console.log(chinese.match(reg)) // [ '正', '则', '表', '达', '式' ]
```

`\u`: 按unicode(utf-8)匹配（主要针对多字节比如汉字）  
`4e00-9fa5`: 中日韩认同表意文字区，总计收容20,902个中日韩汉字  
`g`: 进行全局匹配，即对字符串进行全文匹配，直到字符串遍历结束  
`m`: 更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.)  

### 匹配行尾和行尾行首空格

```js
let reg = /(^\s*)|(\s*$)/g
let part = ` 十年生死两茫茫  写程序  到天亮  千行代码  bug何处藏`
console.log(part.replace(reg,'**')) // **十年生死两茫茫  写程序  到天亮  千行代码  bug何处藏**
```

`\s`: 匹配任意空白符  

### 给日期换一个格式

```js
let reg = /^(\d{4})[/-](\d{2})[/-](\d{2})$/
let time = '2019-10-30'
console.log(time.replace(reg, '$1年$2月$3日')) // 2019年10月30日
console.log(time.replace(reg, '$2/$3/$1')) // 10/30/2019
```

`$1`: 匹配第一组,即第一个括号中的内容

## 匹配位置

> 把位置理解空字符，是对位置非常有效的理解方式  

依然从例子入手：

### 数字的千位分隔符

```js
let string = '12345678 123456789'
let reg = /\B(?=(\d{3})+\b)/g
let result = string.replace(reg, ',')
console.log(result)   // 12,345,678 123,456,789
```

`\b`是单词边界，具体就是 \w 与 \W 之间的位置，也包括 \w 与 ^ 之间的位置，和 \w 与 $ 之间的位置  
`\B`与之相反，即除了\b匹配的位置之外的位置  
`(?=p)`匹配 p 前面的位置，或者说，该位置后面的字符要匹配 p  
`(?!p)`与之相反，即除p前面的位置之外的其他位置  

分析：  
1、首先弄出所有的逗号：  
    匹配三个数字：`/\d{3}/g`  
    匹配这三个数字前的位置：`/(?=\d{3})/g`  
    匹配所有三个数字前的位置：`/(?=(\d{3})+)/g`  
    三位数是从后面往前数的：`/(?=\d{3}+$)/g`  
2、处理特殊情况：  
    逗号的位置不能是开头：`/(?!^)(?=\d{3}+$)/g`  
    例子中有空格，逗号不能出现在这个位置：`/(?!\b)/g`即相当于`/\B/g`，意思是不匹配单词的边界  
    开头和结尾也是单词的边界，所以将开头和结尾换成\b：`/(?!\b)(?=(\d{3})+\b)/g`即`/\B(?=(\d{3})+\b)/g`  

### 验证密码问题

1、至少包含数字、大写字母或小写字母两种字符  
2、长度不少6不超过12

```js
let reg = /(?!^[0-9]{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[0-9A-Za-z]{6,12}$/;
console.log( reg.test("1234567") );    // false 全是数字
console.log( reg.test("abcdef") );     // false 全是小写字母
console.log( reg.test("ABCDEFGH") );   // false 全是大写字母
console.log( reg.test("ab23C") );      // false 不足6位
console.log( reg.test("ABCDEF234") );  // true 大写字母和数字
console.log( reg.test("abcdEF234") );  // true 三者都有
console.log(reg.test('abcdEF234tttttttttt')) // false 超过12位
```

分析：  
1、不能全部是数字：`/(?!^[0-9]{6,12}$)/`  
2、不能全部是小写字母：`/(?!^[a-z]{6,12}$)/`  
3、不能全部是大写字母：`/(?!^[A-Z]{6,12}$)/`  
4、正常情况： `/^[0-9A-Za-z]{6,12}$/`

## 未完待续

[各字符总结](https://www.baidufe.com/item/eb10deb92f2c05ca32cf.html)
